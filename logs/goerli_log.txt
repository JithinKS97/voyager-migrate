3/22/2023, 6:25:35 PM: 0x006a4c7dc63c704388167e3a83fab57e219aa3868fc8ee406a09bb78728e2b17: Failed with all versions
3/22/2023, 6:25:41 PM: 0x00907d3556cbdac15488a5f906d8ae82c7bcd614441b85f539a21e63084b7fc6: "Error occurred"
3/22/2023, 6:25:49 PM: 0x00c8989539a7ef7123401658f1cecaf8c3d9e78233579917189b15fb832c0ee5: "Error occurred"
3/22/2023, 6:25:53 PM: 0x011526cc0f7883d396ca270f5151ff5e76829d855e9787d91e3fafe520fbfcc8: Unable to parse: ["%lang starknet","%builtins pedersen range_check ecdsa","","from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin","from starkware.starknet.common.syscalls import get_caller_address","from starkware.cairo.common.math import assert_not_zero","from starkware.cairo.common.uint256 import (","    Uint256, uint256_add, uint256_sub, uint256_le, uint256_lt, uint256_check",")","","#","# Storage","#","","@storage_var","func _name() -> (res: felt):","end","","@storage_var","func _symbol() -> (res: felt):","end","","@storage_var","func _decimals() -> (res: felt):","end","","@storage_var","func total_supply() -> (res: Uint256):","end","","@storage_var","func balances(account: felt) -> (res: Uint256):","end","","@storage_var","func allowances(owner: felt, spender: felt) -> (res: Uint256):","end","","#","# Constructor","#","","@constructor","func constructor{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        name: felt,","        symbol: felt,","        recipient: felt","    ):","    # get_caller_address() returns '0' in the constructor;","    # therefore, recipient parameter is included","    _name.write(name)","    _symbol.write(symbol)","    _decimals.write(18)","    _mint(recipient, Uint256(1000, 0))","    return ()","end","","#","# Getters","#","","@view","func name{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (name: felt):","    let (name) = _name.read()","    return (name)","end","","@view","func symbol{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (symbol: felt):","    let (symbol) = _symbol.read()","    return (symbol)","end","","@view","func totalSupply{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (totalSupply: Uint256):","    let (totalSupply: Uint256) = total_supply.read()","    return (totalSupply)","end","","@view","func decimals{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (decimals: felt):","    let (decimals) = _decimals.read()","    return (decimals)","end","","@view","func balanceOf{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt) -> (balance: Uint256):","    let (balance: Uint256) = balances.read(account=account)","    return (balance)","end","","@view","func allowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(owner: felt, spender: felt) -> (remaining: Uint256):","    let (remaining: Uint256) = allowances.read(owner=owner, spender=spender)","    return (remaining)","end","","#","# Externals","#","","@external","func transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256) -> (success: felt):","    let (sender) = get_caller_address()","    _transfer(sender, recipient, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func transferFrom{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        sender: felt, ","        recipient: felt, ","        amount: Uint256","    ) -> (success: felt):","    alloc_locals","    let (local caller) = get_caller_address()","    let (local caller_allowance: Uint256) = allowances.read(owner=sender, spender=caller)","","    # validates amount <= caller_allowance and returns 1 if true   ","    let (enough_balance) = uint256_le(amount, caller_allowance)","    assert_not_zero(enough_balance)","","    _transfer(sender, recipient, amount)","","    # subtract allowance","    let (new_allowance: Uint256) = uint256_sub(caller_allowance, amount)","    allowances.write(sender, caller, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, amount: Uint256) -> (success: felt):","    let (caller) = get_caller_address()","    _approve(caller, spender, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func increaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, added_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(added_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(caller, spender)","","    # add allowance","    let (local new_allowance: Uint256, is_overflow) = uint256_add(current_allowance, added_value)","    assert (is_overflow) = 0","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func decreaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, subtracted_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(subtracted_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(owner=caller, spender=spender)","    let (local new_allowance: Uint256) = uint256_sub(current_allowance, subtracted_value)","","    # validates new_allowance < current_allowance and returns 1 if true   ","    let (enough_allowance) = uint256_lt(new_allowance, current_allowance)","    assert_not_zero(enough_allowance)","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","#","# Test functions  will remove once extensibility is resolved","#","","@external","func mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    _mint(recipient, amount)","    return ()","end","","@external","func burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(user: felt, amount: Uint256):","    _burn(user, amount)","    return ()","end","","","#","# Internals","#","","func _mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(recipient)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed to be less than total supply","    # which we check for overflow below","    let (new_balance, _: Uint256) = uint256_add(balance, amount)","    balances.write(recipient, new_balance)","","    let (local supply: Uint256) = total_supply.read()","    let (local new_supply: Uint256, is_overflow) = uint256_add(supply, amount)","    assert (is_overflow) = 0","","    total_supply.write(new_supply)","    return ()","end","","func _transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(sender: felt, recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(sender)","    assert_not_zero(recipient)","    uint256_check(amount) # almost surely not needed, might remove after confirmation","","    let (local sender_balance: Uint256) = balances.read(account=sender)","","    # validates amount <= sender_balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, sender_balance)","    assert_not_zero(enough_balance)","","    # subtract from sender","    let (new_sender_balance: Uint256) = uint256_sub(sender_balance, amount)","    balances.write(sender, new_sender_balance)","","    # add to recipient","    let (recipient_balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed by mint to be less than total supply","    let (new_recipient_balance, _: Uint256) = uint256_add(recipient_balance, amount)","    balances.write(recipient, new_recipient_balance)","    return ()","end","","func _approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(caller: felt, spender: felt, amount: Uint256):","    assert_not_zero(caller)","    assert_not_zero(spender)","    uint256_check(amount)","    allowances.write(caller, spender, amount)","    return ()","end","","func _burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(account)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account)","    # validates amount <= balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, balance)","    assert_not_zero(enough_balance)","    ","    let (new_balance: Uint256) = uint256_sub(balance, amount)","    balances.write(account, new_balance)","","    let (supply: Uint256) = total_supply.read()","    let (new_supply: Uint256) = uint256_sub(supply, amount)","    total_supply.write(new_supply)","    return ()","end",""] 
3/22/2023, 6:26:07 PM: 0x0176372b80f3a2974727a0b3504664c211d99d32a049ef8aed0bd7d78c6124f0: "Error occurred"
3/22/2023, 6:26:23 PM: 0x01ee77bc119c1d04e900a493d524fa65ab0290409a8f17e211e90b98cc559418: "Error occurred"
3/22/2023, 6:27:15 PM: 0x01e66a59cdf974219e77e0d2de49c160630b373884cfc1e51ed8372fec99dc3d: Failed with all versions
3/22/2023, 6:28:03 PM: 0x023bdb997e5a0b97f57e0e225644e3032273501e41b05777cf48b02ba726fa55: Failed with all versions
3/22/2023, 6:28:05 PM: 0x024d47d923c0fc30f60deb26d318d4c28134dde16267609efd83f051d4f96872: Unable to parse: ["%lang starknet","%builtins pedersen range_check ecdsa","","from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin","from starkware.starknet.common.syscalls import get_caller_address","from starkware.cairo.common.math import assert_not_zero","from starkware.cairo.common.uint256 import (","    Uint256, uint256_add, uint256_sub, uint256_le, uint256_lt, uint256_check",")","","#","# Storage","#","","@storage_var","func _name() -> (res: felt):","end","","@storage_var","func _symbol() -> (res: felt):","end","","@storage_var","func _decimals() -> (res: felt):","end","","@storage_var","func total_supply() -> (res: Uint256):","end","","@storage_var","func balances(account: felt) -> (res: Uint256):","end","","@storage_var","func allowances(owner: felt, spender: felt) -> (res: Uint256):","end","","#","# Constructor","#","","@constructor","func constructor{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        name: felt,","        symbol: felt,","        recipient: felt","    ):","    # get_caller_address() returns '0' in the constructor;","    # therefore, recipient parameter is included","    _name.write(name)","    _symbol.write(symbol)","    _decimals.write(18)","    _mint(recipient, Uint256(1000, 0))","    return ()","end","","#","# Getters","#","","@view","func name{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (name: felt):","    let (name) = _name.read()","    return (name)","end","","@view","func symbol{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (symbol: felt):","    let (symbol) = _symbol.read()","    return (symbol)","end","","@view","func totalSupply{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (totalSupply: Uint256):","    let (totalSupply: Uint256) = total_supply.read()","    return (totalSupply)","end","","@view","func decimals{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (decimals: felt):","    let (decimals) = _decimals.read()","    return (decimals)","end","","@view","func balanceOf{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt) -> (balance: Uint256):","    let (balance: Uint256) = balances.read(account=account)","    return (balance)","end","","@view","func allowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(owner: felt, spender: felt) -> (remaining: Uint256):","    let (remaining: Uint256) = allowances.read(owner=owner, spender=spender)","    return (remaining)","end","","#","# Externals","#","","@external","func transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256) -> (success: felt):","    let (sender) = get_caller_address()","    _transfer(sender, recipient, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func transferFrom{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        sender: felt, ","        recipient: felt, ","        amount: Uint256","    ) -> (success: felt):","    alloc_locals","    let (local caller) = get_caller_address()","    let (local caller_allowance: Uint256) = allowances.read(owner=sender, spender=caller)","","    # validates amount <= caller_allowance and returns 1 if true   ","    let (enough_balance) = uint256_le(amount, caller_allowance)","    assert_not_zero(enough_balance)","","    _transfer(sender, recipient, amount)","","    # subtract allowance","    let (new_allowance: Uint256) = uint256_sub(caller_allowance, amount)","    allowances.write(sender, caller, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, amount: Uint256) -> (success: felt):","    let (caller) = get_caller_address()","    _approve(caller, spender, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func increaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, added_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(added_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(caller, spender)","","    # add allowance","    let (local new_allowance: Uint256, is_overflow) = uint256_add(current_allowance, added_value)","    assert (is_overflow) = 0","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func decreaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, subtracted_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(subtracted_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(owner=caller, spender=spender)","    let (local new_allowance: Uint256) = uint256_sub(current_allowance, subtracted_value)","","    # validates new_allowance < current_allowance and returns 1 if true   ","    let (enough_allowance) = uint256_lt(new_allowance, current_allowance)","    assert_not_zero(enough_allowance)","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","#","# Test functions  will remove once extensibility is resolved","#","","@external","func mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    _mint(recipient, amount)","    return ()","end","","@external","func burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(user: felt, amount: Uint256):","    _burn(user, amount)","    return ()","end","","","#","# Internals","#","","func _mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(recipient)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed to be less than total supply","    # which we check for overflow below","    let (new_balance, _: Uint256) = uint256_add(balance, amount)","    balances.write(recipient, new_balance)","","    let (local supply: Uint256) = total_supply.read()","    let (local new_supply: Uint256, is_overflow) = uint256_add(supply, amount)","    assert (is_overflow) = 0","","    total_supply.write(new_supply)","    return ()","end","","func _transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(sender: felt, recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(sender)","    assert_not_zero(recipient)","    uint256_check(amount) # almost surely not needed, might remove after confirmation","","    let (local sender_balance: Uint256) = balances.read(account=sender)","","    # validates amount <= sender_balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, sender_balance)","    assert_not_zero(enough_balance)","","    # subtract from sender","    let (new_sender_balance: Uint256) = uint256_sub(sender_balance, amount)","    balances.write(sender, new_sender_balance)","","    # add to recipient","    let (recipient_balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed by mint to be less than total supply","    let (new_recipient_balance, _: Uint256) = uint256_add(recipient_balance, amount)","    balances.write(recipient, new_recipient_balance)","    return ()","end","","func _approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(caller: felt, spender: felt, amount: Uint256):","    assert_not_zero(caller)","    assert_not_zero(spender)","    uint256_check(amount)","    allowances.write(caller, spender, amount)","    return ()","end","","func _burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(account)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account)","    # validates amount <= balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, balance)","    assert_not_zero(enough_balance)","    ","    let (new_balance: Uint256) = uint256_sub(balance, amount)","    balances.write(account, new_balance)","","    let (supply: Uint256) = total_supply.read()","    let (new_supply: Uint256) = uint256_sub(supply, amount)","    total_supply.write(new_supply)","    return ()","end",""] 
3/22/2023, 6:28:58 PM: 0x027110a376f06d4926b2f1214e25caabca22a3692c573513212201630ef5e8b5: Failed with all versions
3/22/2023, 6:29:04 PM: 0x02a5de1b145e18dfeb31c7cd7ff403714ededf5f3fdf75f8b0ac96f2017541bc: {"message":"Internal server error"}
3/22/2023, 6:29:32 PM: 0x035401b96dc690eda2716068d3b03732d7c18af7c0327787660179108789d84f: "Error occurred"
3/22/2023, 6:33:59 PM: 0x04493f144e26366c9055d28a5d1e7f8aa12f0197f52b309d71341446c963b8e0: Failed with all versions
3/22/2023, 6:34:03 PM: 0x04746d8e8742fea6276da0907d4987720726dfe8829826bba548d025806ecf92: {"message":"Internal server error"}
3/22/2023, 6:35:27 PM: 0x04a613ef6d8abb7e3a254a135844f5da0dde6c361c7057b1c11b022bb24daa78: Failed with all versions
3/22/2023, 6:35:44 PM: 0x04d3b21d4c9632758175019df485361e68844800fe52ce02058199a778c3a391: "Error occurred"
3/22/2023, 6:36:22 PM: 0x054d8870ecd09d7439624bfd83785d0ad8767c820a73650fd5a0cf96f63c9c96: {"message":"Internal server error"}
3/22/2023, 6:36:22 PM: 0x0551f45e9d576b3f0fe21b4cbfd588d1517138918c26808a8bb19dc743308f94: {"message":"Internal server error"}
3/22/2023, 6:36:22 PM: 0x05393b9b9180fa1a7b844fbc9632b1124b717e8517793aed57793855efb7e9eb: {"message":"Internal server error"}
3/22/2023, 6:37:16 PM: 0x056bb265caf902c04bba176bd3f77d31d0cba67733931afde7bec14625697dd6: Failed with all versions
3/22/2023, 6:37:53 PM: 0x0598c8dffd2fe97fcad4bd6545846ac97401ade3611e511cd5d2bcdaf0787a09: {"message":"Invalid contract address or class hash"}
3/22/2023, 6:38:18 PM: 0x05b415e69fb7afc21d58ad251a1584992ac25ccb1163507e828e97677ef892a6: "Error occurred"
3/22/2023, 6:38:20 PM: 0x05bc8cc601c5098e20e9d9d74e86cfb0ec737f6f3ac571914dbe4f74aa249786: "Error occurred"
3/22/2023, 6:39:03 PM: 0x0616079fd1cebc71aca96c482fa75848ff26275b2cf4452051032fa43c732813: "Error occurred"
3/22/2023, 6:39:05 PM: 0x062226e8b360c5e08af59648fa88190c14f2847331684a8e589d851daa185c4e: {"message":"Internal server error"}
3/22/2023, 6:39:05 PM: 0x06376bc6878c03df258cc2a527fed09fc2ec2e3aba2ed94bf54807434c0d268d: {"message":"Internal server error"}
3/22/2023, 6:39:22 PM: 0x063ac5be9a6fef3938fdd282105ff47ecbfffc6e2b662939903148293d56dcef: "Error occurred"
3/22/2023, 6:41:02 PM: 0x06f7d6689843b9852567dd368dca92906d253e5f942981920b1e45e5d131b0f7: {"message":"Internal server error"}
3/22/2023, 6:41:07 PM: 0x070087d69701a0cf86967d95429d1151c0bcc67b59bf02a8049b0c0e6fe33f76: "Error occurred"
3/22/2023, 6:41:15 PM: 0x07394cbe418daa16e42b87ba67372d4ab4a5df0b05c6e554d158458ce245bc10: Unable to parse: ["%lang starknet","%builtins pedersen range_check ecdsa","","from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin","from starkware.starknet.common.syscalls import get_caller_address","from starkware.cairo.common.math import assert_not_zero","from starkware.cairo.common.uint256 import (","    Uint256, uint256_add, uint256_sub, uint256_le, uint256_lt, uint256_check)","","#","# Storage","#","","@storage_var","func _name() -> (res : felt):","end","","@storage_var","func _symbol() -> (res : felt):","end","","@storage_var","func _decimals() -> (res : felt):","end","","@storage_var","func total_supply() -> (res : Uint256):","end","","@storage_var","func balances(account : felt) -> (res : Uint256):","end","","@storage_var","func allowances(owner : felt, spender : felt) -> (res : Uint256):","end","","#","# Constructor","#","","@constructor","func constructor{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        name : felt, symbol : felt, recipient : felt):","    # get_caller_address() returns '0' in the constructor;","    # therefore, recipient parameter is included","    _name.write(name)","    _symbol.write(symbol)","    _decimals.write(18)","    _mint(recipient, Uint256(1000, 0))","    return ()","end","","#","# Getters","#","","@view","func name{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (name : felt):","    let (name) = _name.read()","    return (name)","end","","@view","func symbol{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (symbol : felt):","    let (symbol) = _symbol.read()","    return (symbol)","end","","@view","func totalSupply{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (","        totalSupply : Uint256):","    let (totalSupply : Uint256) = total_supply.read()","    return (totalSupply)","end","","@view","func decimals{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() -> (","        decimals : felt):","    let (decimals) = _decimals.read()","    return (decimals)","end","","@view","func balanceOf{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        account : felt) -> (balance : Uint256):","    let (balance : Uint256) = balances.read(account=account)","    return (balance)","end","","@view","func allowance{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        owner : felt, spender : felt) -> (remaining : Uint256):","    let (remaining : Uint256) = allowances.read(owner=owner, spender=spender)","    return (remaining)","end","","#","# Externals","#","","@external","func transfer{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        recipient : felt, amount : Uint256) -> (success : felt):","    let (sender) = get_caller_address()","    _transfer(sender, recipient, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func transferFrom{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        sender : felt, recipient : felt, amount : Uint256) -> (success : felt):","    alloc_locals","    let (local caller) = get_caller_address()","    let (local caller_allowance : Uint256) = allowances.read(owner=sender, spender=caller)","","    # validates amount <= caller_allowance and returns 1 if true","    let (enough_balance) = uint256_le(amount, caller_allowance)","    assert_not_zero(enough_balance)","","    _transfer(sender, recipient, amount)","","    # subtract allowance","    let (new_allowance : Uint256) = uint256_sub(caller_allowance, amount)","    allowances.write(sender, caller, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func approve{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        spender : felt, amount : Uint256) -> (success : felt):","    let (caller) = get_caller_address()","    _approve(caller, spender, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func increaseAllowance{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        spender : felt, added_value : Uint256) -> (success : felt):","    alloc_locals","    uint256_check(added_value)","    let (local caller) = get_caller_address()","    let (local current_allowance : Uint256) = allowances.read(caller, spender)","","    # add allowance","    let (local new_allowance : Uint256, is_overflow) = uint256_add(current_allowance, added_value)","    assert (is_overflow) = 0","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func decreaseAllowance{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        spender : felt, subtracted_value : Uint256) -> (success : felt):","    alloc_locals","    uint256_check(subtracted_value)","    let (local caller) = get_caller_address()","    let (local current_allowance : Uint256) = allowances.read(owner=caller, spender=spender)","    let (local new_allowance : Uint256) = uint256_sub(current_allowance, subtracted_value)","","    # validates new_allowance < current_allowance and returns 1 if true","    let (enough_allowance) = uint256_lt(new_allowance, current_allowance)","    assert_not_zero(enough_allowance)","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","#","# Test functions  will remove once extensibility is resolved","#","","@external","func mint{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        recipient : felt, amount : Uint256):","    _mint(recipient, amount)","    return ()","end","","@external","func burn{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        user : felt, amount : Uint256):","    _burn(user, amount)","    return ()","end","","#","# Internals","#","","func _mint{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        recipient : felt, amount : Uint256):","    alloc_locals","    assert_not_zero(recipient)","    uint256_check(amount)","","    let (balance : Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed to be less than total supply","    # which we check for overflow below","    let (new_balance, _ : Uint256) = uint256_add(balance, amount)","    balances.write(recipient, new_balance)","","    let (local supply : Uint256) = total_supply.read()","    let (local new_supply : Uint256, is_overflow) = uint256_add(supply, amount)","    assert (is_overflow) = 0","","    total_supply.write(new_supply)","    return ()","end","","func _transfer{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        sender : felt, recipient : felt, amount : Uint256):","    alloc_locals","    assert_not_zero(sender)","    assert_not_zero(recipient)","    uint256_check(amount)  # almost surely not needed, might remove after confirmation","","    let (local sender_balance : Uint256) = balances.read(account=sender)","","    # validates amount <= sender_balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, sender_balance)","    assert_not_zero(enough_balance)","","    # subtract from sender","    let (new_sender_balance : Uint256) = uint256_sub(sender_balance, amount)","    balances.write(sender, new_sender_balance)","","    # add to recipient","    let (recipient_balance : Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed by mint to be less than total supply","    let (new_recipient_balance, _ : Uint256) = uint256_add(recipient_balance, amount)","    balances.write(recipient, new_recipient_balance)","    return ()","end","","func _approve{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        caller : felt, spender : felt, amount : Uint256):","    assert_not_zero(caller)","    assert_not_zero(spender)","    uint256_check(amount)","    allowances.write(caller, spender, amount)","    return ()","end","","func _burn{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(","        account : felt, amount : Uint256):","    alloc_locals","    assert_not_zero(account)","    uint256_check(amount)","","    let (balance : Uint256) = balances.read(account)","    # validates amount <= balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, balance)","    assert_not_zero(enough_balance)","","    let (new_balance : Uint256) = uint256_sub(balance, amount)","    balances.write(account, new_balance)","","    let (supply : Uint256) = total_supply.read()","    let (new_supply : Uint256) = uint256_sub(supply, amount)","    total_supply.write(new_supply)","    return ()","end",""] 
3/22/2023, 6:41:58 PM: 0x0766e203bbd6d0b64f74ae511b5377fe2b29ad6ee1c28207fef133c9ef2bee63: "Error occurred"
3/22/2023, 6:42:03 PM: 0x0775d223502e7dc5437284691d8cd47fadd8fc0926836c784f6d8102d4524246: {"message":"Internal server error"}
3/22/2023, 6:42:03 PM: 0x07756d458d88211e4230faf988b813c5259618b8196dadc70ec802f858c7935f: {"message":"Internal server error"}
3/22/2023, 6:42:03 PM: 0x077cd83ef7e11d8d55acdce4dc9b441c5b58ae3f26853dfd5be77cf0c5f3c623: {"message":"Internal server error"}
3/22/2023, 6:42:03 PM: 0x078090a19fb97815d3c7f4b209fcee7a915f2e2be69c5d1dab56295129fdd9a3: {"message":"Internal server error"}
3/22/2023, 6:43:02 PM: 0x07eb3cb3af49e16fb25d717817453a2eaaf84e9a413caa535ad3d2b46c2ff935: {"message":"Internal server error"}
3/22/2023, 6:50:57 PM: 0x011526cc0f7883d396ca270f5151ff5e76829d855e9787d91e3fafe520fbfcc8: Unable to parse: ["%lang starknet","%builtins pedersen range_check ecdsa","","from starkware.cairo.common.cairo_builtins import HashBuiltin, SignatureBuiltin","from starkware.starknet.common.syscalls import get_caller_address","from starkware.cairo.common.math import assert_not_zero","from starkware.cairo.common.uint256 import (","    Uint256, uint256_add, uint256_sub, uint256_le, uint256_lt, uint256_check",")","","#","# Storage","#","","@storage_var","func _name() -> (res: felt):","end","","@storage_var","func _symbol() -> (res: felt):","end","","@storage_var","func _decimals() -> (res: felt):","end","","@storage_var","func total_supply() -> (res: Uint256):","end","","@storage_var","func balances(account: felt) -> (res: Uint256):","end","","@storage_var","func allowances(owner: felt, spender: felt) -> (res: Uint256):","end","","#","# Constructor","#","","@constructor","func constructor{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        name: felt,","        symbol: felt,","        recipient: felt","    ):","    # get_caller_address() returns '0' in the constructor;","    # therefore, recipient parameter is included","    _name.write(name)","    _symbol.write(symbol)","    _decimals.write(18)","    _mint(recipient, Uint256(1000, 0))","    return ()","end","","#","# Getters","#","","@view","func name{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (name: felt):","    let (name) = _name.read()","    return (name)","end","","@view","func symbol{","        syscall_ptr : felt*,","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (symbol: felt):","    let (symbol) = _symbol.read()","    return (symbol)","end","","@view","func totalSupply{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (totalSupply: Uint256):","    let (totalSupply: Uint256) = total_supply.read()","    return (totalSupply)","end","","@view","func decimals{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }() -> (decimals: felt):","    let (decimals) = _decimals.read()","    return (decimals)","end","","@view","func balanceOf{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt) -> (balance: Uint256):","    let (balance: Uint256) = balances.read(account=account)","    return (balance)","end","","@view","func allowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(owner: felt, spender: felt) -> (remaining: Uint256):","    let (remaining: Uint256) = allowances.read(owner=owner, spender=spender)","    return (remaining)","end","","#","# Externals","#","","@external","func transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256) -> (success: felt):","    let (sender) = get_caller_address()","    _transfer(sender, recipient, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func transferFrom{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(","        sender: felt, ","        recipient: felt, ","        amount: Uint256","    ) -> (success: felt):","    alloc_locals","    let (local caller) = get_caller_address()","    let (local caller_allowance: Uint256) = allowances.read(owner=sender, spender=caller)","","    # validates amount <= caller_allowance and returns 1 if true   ","    let (enough_balance) = uint256_le(amount, caller_allowance)","    assert_not_zero(enough_balance)","","    _transfer(sender, recipient, amount)","","    # subtract allowance","    let (new_allowance: Uint256) = uint256_sub(caller_allowance, amount)","    allowances.write(sender, caller, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, amount: Uint256) -> (success: felt):","    let (caller) = get_caller_address()","    _approve(caller, spender, amount)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func increaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, added_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(added_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(caller, spender)","","    # add allowance","    let (local new_allowance: Uint256, is_overflow) = uint256_add(current_allowance, added_value)","    assert (is_overflow) = 0","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","@external","func decreaseAllowance{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(spender: felt, subtracted_value: Uint256) -> (success: felt):","    alloc_locals","    uint256_check(subtracted_value)","    let (local caller) = get_caller_address()","    let (local current_allowance: Uint256) = allowances.read(owner=caller, spender=spender)","    let (local new_allowance: Uint256) = uint256_sub(current_allowance, subtracted_value)","","    # validates new_allowance < current_allowance and returns 1 if true   ","    let (enough_allowance) = uint256_lt(new_allowance, current_allowance)","    assert_not_zero(enough_allowance)","","    _approve(caller, spender, new_allowance)","","    # Cairo equivalent to 'return (true)'","    return (1)","end","","#","# Test functions  will remove once extensibility is resolved","#","","@external","func mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    _mint(recipient, amount)","    return ()","end","","@external","func burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(user: felt, amount: Uint256):","    _burn(user, amount)","    return ()","end","","","#","# Internals","#","","func _mint{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(recipient)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed to be less than total supply","    # which we check for overflow below","    let (new_balance, _: Uint256) = uint256_add(balance, amount)","    balances.write(recipient, new_balance)","","    let (local supply: Uint256) = total_supply.read()","    let (local new_supply: Uint256, is_overflow) = uint256_add(supply, amount)","    assert (is_overflow) = 0","","    total_supply.write(new_supply)","    return ()","end","","func _transfer{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(sender: felt, recipient: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(sender)","    assert_not_zero(recipient)","    uint256_check(amount) # almost surely not needed, might remove after confirmation","","    let (local sender_balance: Uint256) = balances.read(account=sender)","","    # validates amount <= sender_balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, sender_balance)","    assert_not_zero(enough_balance)","","    # subtract from sender","    let (new_sender_balance: Uint256) = uint256_sub(sender_balance, amount)","    balances.write(sender, new_sender_balance)","","    # add to recipient","    let (recipient_balance: Uint256) = balances.read(account=recipient)","    # overflow is not possible because sum is guaranteed by mint to be less than total supply","    let (new_recipient_balance, _: Uint256) = uint256_add(recipient_balance, amount)","    balances.write(recipient, new_recipient_balance)","    return ()","end","","func _approve{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(caller: felt, spender: felt, amount: Uint256):","    assert_not_zero(caller)","    assert_not_zero(spender)","    uint256_check(amount)","    allowances.write(caller, spender, amount)","    return ()","end","","func _burn{","        syscall_ptr : felt*, ","        pedersen_ptr : HashBuiltin*,","        range_check_ptr","    }(account: felt, amount: Uint256):","    alloc_locals","    assert_not_zero(account)","    uint256_check(amount)","","    let (balance: Uint256) = balances.read(account)","    # validates amount <= balance and returns 1 if true","    let (enough_balance) = uint256_le(amount, balance)","    assert_not_zero(enough_balance)","    ","    let (new_balance: Uint256) = uint256_sub(balance, amount)","    balances.write(account, new_balance)","","    let (supply: Uint256) = total_supply.read()","    let (new_supply: Uint256) = uint256_sub(supply, amount)","    total_supply.write(new_supply)","    return ()","end",""] 
3/22/2023, 6:51:01 PM: 0x00907d3556cbdac15488a5f906d8ae82c7bcd614441b85f539a21e63084b7fc6: "Error occurred"
3/22/2023, 6:51:01 PM: 0x0176372b80f3a2974727a0b3504664c211d99d32a049ef8aed0bd7d78c6124f0: "Error occurred"
3/22/2023, 6:51:01 PM: 0x00c8989539a7ef7123401658f1cecaf8c3d9e78233579917189b15fb832c0ee5: "Error occurred"
